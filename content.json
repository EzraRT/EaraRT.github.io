{"meta":{"title":"EzraRT","subtitle":"小博客","description":"博客","author":"EzraRT","url":"https://ezrart.github.io","root":"/"},"pages":[{"title":"tags","date":"2020-11-16T15:02:09.000Z","updated":"2023-06-28T05:12:04.137Z","comments":true,"path":"tags/index.html","permalink":"https://ezrart.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-11-16T15:01:16.000Z","updated":"2023-06-28T05:12:14.843Z","comments":true,"path":"categories/index.html","permalink":"https://ezrart.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"re:start","slug":"re-start","date":"2023-06-26T15:10:17.000Z","updated":"2023-06-26T15:10:17.000Z","comments":true,"path":"/2023/06/26/re-start/","link":"","permalink":"https://ezrart.github.io/2023/06/26/re-start/","excerpt":"","text":"计划重新拾起博客 别太怠惰","categories":[],"tags":[]},{"title":"使用CMake来构建项目","slug":"cmake","date":"2020-11-21T07:46:58.000Z","updated":"2020-11-21T07:46:58.000Z","comments":true,"path":"/2020/11/21/cmake/","link":"","permalink":"https://ezrart.github.io/2020/11/21/cmake/","excerpt":"","text":"Cmake的使用CMake是什么Cmake是一种跨平台的项目构建工具，它使用符合CMake要求的项目来生成平台原生的项目，从而利用平台原生的工具来构建你的项目。 例如： 平台类型 生成的项目类型 UNIX&#x2F;LINUX Makefile构建的项目 Windows Visual Studio项目 Mac OS XCode项目 CMake的用法cmake [路径] 即可生成对应的项目，以Linux平台为例，cmake可以为我们制作出Makefile项目，再执行 make 即可得到我们想要的可执行文件 CMake构建的项目何为CMake构建的项目？CMake构建的项目使用CMakeLists.txt文件来描述项目的组织情况，一个CMakeLists.txt应该具有如下要素 cmake_minimum_required(VERSION 构建此项目所需的最低cmake版本)project(项目名)# 添加一个可执行文件add_executable(可执行文件名 组成该可执行文件的所有源代码文件名的列表)# 添加一个静态库add_library(库名 STATIC 组成该库的所有源代码文件名的列表)# 将两个或多个target[s]链接起来target_link_libraries(生成的target[可执行文件名/库名] 它所需链接的target[s]列表) 第一句，制定了此项目所需的最低cmake版本，一般地，此版本应设置为3.0.0； 第二句，设定了该项目的名称； 第三句，设定了一个可执行文件作为target（目标），即此句话的目的是生成该目标，而为了生成该目标，需要对它进行一些描述，一般是指构建它所需的所有源文件名； 第四句，设定了一个库作为target（目标），即此句话的目的是生成该目标； 第五句，用于在需要链接外部库或自己定义的库的时候，用于将它们链接起来。 一些实例HelloWorld俗话说得好，不知道写什么的时候就写Hello,World!其实是我说的 项目中文件如下 main.c CMakeLists.txt # CMakeLists.txtcmake_minimum_required(VERSION 3.0.0)project(helloworld)add_executable(hello main.c) // main.c#include &lt;stdio.h&gt;int main()&#123; printf(&quot;Hello,World!\\n&quot;);&#125; 再执行 # .代表当前目录，..代表上级目录cmake .make 即可得到可执行文件hello了 多文件项目项目中文件如下 main.c add.h add.c CMakeLists.txt # CMakeLists.txtcmake_minimum_required(VERSION 3.0.0)project(add_test)add_executable(add_test_exec main.c add.c) // add.h#ifndef __FUNC_H__#define __FUNC_H__int add(int, int);#endif // __FUNC_H__ // add.c#include &quot;add.h&quot;int add(int a, int b)&#123; return a + b;&#125; // main.c#include &quot;add.h&quot;#include &lt;stdio.h&gt;int main()&#123; printf(&quot;%d\\n&quot;, add(1, 2));&#125; 库项目库是什么？库是程序的一部分，但它不可以直接执行，通常库中包含了库所编写的函数的实现，但并没有main函数，即它不能自己执行，需要别的程序来调用它才能执行。从链接方式上来看，库分为静态库（static）和动态库（dynamic）。 静态库类似多文件项目中，某源文件编译过程中生成的二进制文件，它保留了函数入口及实现。将在链接后被包含到可执行文件中； 动态库在链接时仅告诉可执行文件一些函数的信息，而不告诉它具体的实现，而在运行时，可执行文件会在某些规则下寻找动态库文件并将其载入内存中进行函数调用。 不难看出，动态库的优点在于节省了可执行文件的体积，而且多个不同的可执行文件可以共享一份动态库文件，从而有效节约硬盘资源。但其也有弊端，比如程序在别的计算机上运行时，可能那台计算机并没有所需的动态库，则需要将动态库也拷贝一份，否则程序将无法执行，而使用静态库的程序只要拷贝一个可执行文件就可以运行了。 此处我们使用一个静态库项目来举例 项目中文件如下 add.h add.c CMakeLists.txt # CMakeLists.txtcmake_minimum_required(VERSION 3.0.0)project(add)# static是指生成静态库add_library(add STATIC add.c) // add.h#ifndef __FUNC_H__#define __FUNC_H__int add(int, int);#endif // __FUNC_H__ // add.c#include &quot;add.h&quot;int add(int a, int b)&#123; return a + b;&#125; Linux平台下构建得到libadd.a文件，a是指archive，译为档案，就是静态库的意思，add是我们生成的库名，通过执行 ar -t ./libadd.a 可以得到这个档案中所包含的内容，此处为add.c.o，正是我们add.c在编译时产生的二进制文件！也就是称库与源文件编译过程中生成的二进制文件类似的原因。 同理Windows下会得到后缀名为lib的库文件，lib是library的意思。 使用库的项目我们写好了一个库，那就要给别人&#x2F;自己用啊。如何利用cmake来将库加入自己的项目中呢？ 项目中文件如下 add.h main.c libadd.a CMakeLists.txt # CMakeLists.txtcmake_minimum_required(VERSION 3.0.0)project(test_lib_add)# 此处指定了库所在的目录，如果不指定的话，系统会在系统设置的环境变量中遍历寻找link_directories(.)add_executable(test_lib_add main.c)# 将add库与测试add的项目链接起来target_link_libraries(test_lib_add add) // add.h#ifndef __FUNC_H__#define __FUNC_H__int add(int, int);#endif // __FUNC_H__ // main.c#include &quot;add.h&quot;#include &lt;stdio.h&gt;int main()&#123; printf(&quot;%d\\n&quot;, add(1, 2));&#125; 想要使用库文件，必须知道我们需要使用的函数的定义，即拥有上例add库的头文件add.h 而在链接时需要函数实现，故还需add库生成的libadd.a文件 我们与多文件项目相比可谓是多此一举，但使用库有什么意义呢？ 答案是隐藏了你的源码。在使用库的项目测试中，无需add.c来告诉编译器add函数如何实现，只是借add.h告诉了编译器：“我有个函数叫add，使用两个int做参数，使用int做返回值，你看着办！” 而编译器会在链接时，尝试找到所有未实现的函数并把它们的定义和其实现（在库文件中）进行关联，从而生成可执行程序。 而且用户无需考虑你的具体实现，只要调用它即可。现在很多项目都是使用这种方法来提供自己的API（Application Programming Interface，类似于此处的函数定义）的。 其他实例更多实例请看这个开源项目","categories":[{"name":"编译工具","slug":"编译工具","permalink":"https://ezrart.github.io/categories/%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://ezrart.github.io/tags/C-C/"},{"name":"编译","slug":"编译","permalink":"https://ezrart.github.io/tags/%E7%BC%96%E8%AF%91/"},{"name":"cmake","slug":"cmake","permalink":"https://ezrart.github.io/tags/cmake/"}]},{"title":"自动化编译流程","slug":"makefile","date":"2020-11-18T14:16:31.000Z","updated":"2020-11-18T14:16:31.000Z","comments":true,"path":"/2020/11/18/makefile/","link":"","permalink":"https://ezrart.github.io/2020/11/18/makefile/","excerpt":"","text":"自动化编译流程前置知识C&#x2F;C++语言的编译过程不妨查看这里 为什么要自动化编译用命令行一条指令地执行来编译也未尝不可，但对于大型项目，尤其是较多文件的项目来说，每次编译都要输入一大串命令是不可忍受的，聪明的孩子可能会想到：“那我写一个脚本来执行编译命令不就皆大欢喜了吗？”确实是这样。 对于一个简单的项目，我们可以编写一个脚本，在其中按顺序设定好编译所需的所有指令，每次编译只要执行它就好了，但如果你更改了其中一个文件，重新编译便要把所有文件重新编译一遍再链接，如果其它文件没有改动，那这不是白白浪费了时间？ 使用makefile来管理我们的编译流程makefile是一种特殊的脚本标记语言，它文件名就叫做makefile[或Makefile] 我们在项目的根部录下创建一个makefile文件 makefile的语法如下： target1 : dependency1 [dependency2] ... Command target2 : dependency1 [dependency2] ... Command ...... 这是什么意思呢？ 直接举一个例子 我们有一个多文件的项目，源代码为main.c、add.c、add.h，其中main.c，add.c都include了add.h 我们编译需要执行的命令有三条 #编译main.cgcc -c -o main.o ./main.c #编译add.cgcc -c -o add.o ./add.c#链接得到可执行文件gcc -o main ./main.o ./add.o 其中第一条命令是得到main.c编译后得到的main.o，其中，main.o就是makefile中的target，而得到main.o所需的依赖为main.c文件，而main.c中引入了add.h头文件，故add.h也是main.o的依赖。所以makfile中，得到main.o所需的标记如下 main.o : main.c add.h gcc -c -o main.o ./main.c#注意上一行开头是一个tab符 同理，得到add.o的标记如下 add.o : add.c add.h gcc -c -o add.o ./add.c#注意上一行开头是一个tab符 而最终想得到的可执行文件main的标记如下 #使用all来指示target，这是执行make时默认生成的targetall : main.o add.o gcc -o main ./main.o ./add.o#注意上一行开头是一个tab符 将它们写在同一个makefile文件中，便得到了我们所需的makefile文件 all : main.o add.o gcc -o main ./main.o ./add.omain.o : main.c add.h gcc -c -o main.o ./main.cadd.o : add.c add.h gcc -c -o add.o ./add.c Windows下安装了gcc之后，有一个make.exe供我们使用，它便是用来解析并执行makefile文件中的命令的程序。（Linux使用make来构建更方便） 我们在makefile同一目录下执行 make 短短的四个字，为我们带来了无尽的方便。 makefile的优势但和普通脚本相比，makefile文件多写了很多字啊，这不是反而麻烦了吗？ 其实不然，上文说到普通脚本会暴力的执行每一步操作，而makefile标记的编译过程，每次执行make，make会检查每一个target及其dependency。 如果target不存在，好的，执行下一行的Command来得到target； 如果target依赖于某个or某些dependency，好的，先去检查这些dependency的获取方式； 如果dependency不存在，好的，先去搜索如何得到dependency； 如果dependency被改变了，好的，重新构建该target。 这时makefile的优势便体现了出来，本例中，假设我已经编译了程序，结果发现我add.c中的add函数有bug！我把它写成减法了！我改动了add.c文件使其能完成正确的操作。再次执行make时，它进行检查： all 依赖于 main.o 与 add.o，先去检查它们 main.o 依赖于 main.c 与 add.h，这两个文件都没有改变（相比与上一次make），且make.o已经存在（上一次make生成的），所以main.o是已经生成好了的。（跳过此target指示的Command） add.o 依赖于 add.c 与 add.h，发现add.c被改变了！将重新生成add.o。（执行下一行的Command） 对all的依赖检查结束，发现至少有一个依赖不存在或已经改变。（此处为add.o）重新生成all（执行下一行的Command） 对于简单地执行脚本，我们少执行了一条编译main.c的指令。在此处优势还不太明显，但在大型项目组织中，这无疑是最好的构建方法，对于单个文件的改动，不会重复地去编译其他的源代码，从而大大减少了编译时间。（C&#x2F;C++编译速度慢也是它们常年来被诟病的一个点）","categories":[{"name":"编译工具","slug":"编译工具","permalink":"https://ezrart.github.io/categories/%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://ezrart.github.io/tags/C-C/"},{"name":"编译","slug":"编译","permalink":"https://ezrart.github.io/tags/%E7%BC%96%E8%AF%91/"}]},{"title":"C与C++的编译","slug":"compile","date":"2020-11-18T14:16:30.000Z","updated":"2020-11-18T14:16:30.000Z","comments":true,"path":"/2020/11/18/compile/","link":"","permalink":"https://ezrart.github.io/2020/11/18/compile/","excerpt":"","text":"C&#x2F;C++的编译过程以GCC编译器为例 总览 使用gcc命令行一步一步编译的命令为： gcc [option] -o 用于保存结果的文件名 输入文件名 其中option即为图中的-E -S -c一个源代码文件要经过上述过程才能被编译成可执行文件，下面对其中每个步骤做一些介绍 预处理一个源代码中包含了#include、#ifdef等预处理语句以及宏定义等内容，而在编译时，它们都会被展开，例如如下的源程序 //main.c#include &lt;stdio.h&gt;#include &quot;add.h&quot;#define PI 3.14int main(int argc, char const* argv[])&#123; char temp[80]; double ss = PI; printf(&quot;Hello,World!\\n&quot;); printf(&quot;%d\\n&quot;, add(1, 2));//此add函数在add.c中实现 return 0;&#125; //add.h#ifndef __ADD_H__#define __ADD_H__int add(int a, int b);//仅函数声明#endif // __ADD_H__ //add.c#include &quot;add.h&quot;int add(int a, int b)&#123; return a + b;&#125; 我们include了stdio.h，add.h这些头文件，宏定义了一个PI，并在main函数中进行了一些简单的操作，在add.c中实现了一个简单的加法函数，而对main.c预处理之后，它变成了这样 //main.i# 1 &quot;./main.c&quot;# 1 &quot;&lt;built-in&gt;&quot;/*此处省略一万个stdio.h中的类型重名*/const char *__mingw_get_crt_info (void);# 11 &quot;D:/Tools/GCC/x86_64-w64-mingw32/include/crtdefs.h&quot; 2 3#pragma pack(push,_CRT_PACKING)# 35 &quot;D:/Tools/GCC/x86_64-w64-mingw32/include/crtdefs.h&quot; 3__extension__ typedef unsigned long long size_t;# 45 &quot;D:/Tools/GCC/x86_64-w64-mingw32/include/crtdefs.h&quot; 3__extension__ typedef long long ssize_t;typedef size_t rsize_t;# 62 &quot;D:/Tools/GCC/x86_64-w64-mingw32/include/crtdefs.h&quot; 3__extension__ typedef long long intptr_t;# 75 &quot;D:/Tools/GCC/x86_64-w64-mingw32/include/crtdefs.h&quot; 3__extension__ typedef unsigned long long uintptr_t;# 88 &quot;D:/Tools/GCC/x86_64-w64-mingw32/include/crtdefs.h&quot; 3__extension__ typedef long long ptrdiff_t;# 98 &quot;D:/Tools/GCC/x86_64-w64-mingw32/include/crtdefs.h&quot; 3typedef unsigned short wchar_t;typedef unsigned short wint_t;typedef unsigned short wctype_t;typedef int errno_t;/*此处省略一万个stdio.h中的函数声明*/# 2 &quot;./main.c&quot; 2# 1 &quot;./add.h&quot; 1# 4 &quot;./add.h&quot;int add(int a, int b);# 4 &quot;./main.c&quot; 2int main(int argc, char const* argv[])&#123; char temp[80]; double ss = 3.14; printf(&quot;Hello,World!\\n&quot;); printf(&quot;%d\\n&quot;, add(1, 2)); return 0;&#125;//此文件实际共有894行 这种看着像C语言，但又有些不同的语法，便是编译器对源文件预处理后得到的中间产物。对比源文件我们可以发现，我们#include进来的&lt;stdio.h&gt; “add.h” 文件的内容被替换在引入头文件的位置了，且add.h中的预处理命令#ifndef、#define、#endif等等都被处理完了。 而add.c在预处理后变成了这样 //add.i# 1 &quot;./add.c&quot;# 1 &quot;&lt;built-in&gt;&quot;# 1 &quot;&lt;command-line&gt;&quot;# 1 &quot;./add.c&quot;# 1 &quot;./add.h&quot; 1int add(int a, int b);# 2 &quot;./add.c&quot; 2int add(int a, int b)&#123; return a + b;&#125;//此文件没有省略，因为add.c和其include进来的add.h头文件都没有再include其他文件，故仅有这些内容 编译此处的编译是将预处理后的那种带有奇怪标记的中间文件编译成汇编语言文件 此处得到的结果为 //main.s .file &quot;main.c&quot; .text .def __main; .scl 2; .type 32; .endef .section .rdata,&quot;dr&quot;.LC1: .ascii &quot;Hello,World!\\0&quot;.LC2: .ascii &quot;%d\\12\\0&quot; .text .globl main .def main; .scl 2; .type 32; .endef .seh_proc mainmain: pushq %rbp .seh_pushreg %rbp movq %rsp, %rbp .seh_setframe %rbp, 0 addq $-128, %rsp .seh_stackalloc 128 .seh_endprologue movl %ecx, 16(%rbp) movq %rdx, 24(%rbp) call __main movsd .LC0(%rip), %xmm0 movsd %xmm0, -8(%rbp) leaq .LC1(%rip), %rcx call puts movl $2, %edx movl $1, %ecx call add movl %eax, %edx leaq .LC2(%rip), %rcx call printf movl $0, %eax subq $-128, %rsp popq %rbp ret .seh_endproc .section .rdata,&quot;dr&quot; .align 8.LC0: .long 1374389535 .long 1074339512 .ident &quot;GCC: (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 8.1.0&quot; .def puts; .scl 2; .type 32; .endef .def add; .scl 2; .type 32; .endef .def printf; .scl 2; .type 32; .endef 没学过汇编语言的人可能会想：“这啥啊，看都看不懂，我写的不是C语言吗，怎么变成这样了” 在编译过程中，将C语言编译成汇编语言，我们的工作就成功大半了。因为汇编语言与机器语言（计算机可以识别、执行的命令）是一一对应的，接下来再进行一些小步骤，就能把我们的文本文件变成计算机可以执行的文件了。 不过这里让我们略微看一看这个汇编代码，在这里 call putsmovl $2, %edxmovl $1, %ecxcall addmovl %eax, %edxleaq .LC2(%rip), %rcxcall printf 是不是看到了一些熟悉的字眼？puts、printf这些都是C语言提供的函数，而add函数是我们自己定义的。call的意思就是去调用这些函数。 汇编得到了汇编代码就可以简单地把它翻译成机器语言了 编译得到main.o文件，使用著名反汇编分析程序IDA打开它，可以发现，它已经不再是简单的文本文件，但当使用软件将它从机器语言再翻译回汇编语言 还是能从中发现一些端倪，比如main函数调用了puts、add、printf函数等 但当我们追踪下去，却发现 它们无一例外地，全都只是一个空入口，此时，编译得到的文件虽然已经是计算机认识的代码了，但有些函数调用只是在原地留了个坑，程序还不知道如何去调用这些程序。 而汇编add.s文件后，得到了add函数。 那么如何让我们main.o与add.o以及printf、puts函数的实现文件联合起来呢？快进到链接。 链接链接不需要加额外参数，只要执行 gcc -o main ./main.o ./add.o 便可以得到可执行文件main.exe了，执行试试 嗯，不错。此时我们再用IDA来分析main.exe文件 找不同时间到，这与刚刚得到的main.o文件有什么不同呢？ 答案是，几乎没有区别，但是！puts、add、printf等字眼变成蓝色了，此时我们再追踪这些函数，终于找到了它们真实的函数入口 例如add函数 至此，我们便完成了一个分文件的项目的编译，由于项目简单，仅有两个源文件，采用gcc命令行编译&amp;链接的方式也不算繁琐。但当项目变得庞大起来，这种方法还靠谱吗？","categories":[{"name":"编译工具","slug":"编译工具","permalink":"https://ezrart.github.io/categories/%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://ezrart.github.io/tags/C-C/"},{"name":"编译","slug":"编译","permalink":"https://ezrart.github.io/tags/%E7%BC%96%E8%AF%91/"},{"name":"makefile","slug":"makefile","permalink":"https://ezrart.github.io/tags/makefile/"}]},{"title":"Git的使用","slug":"Git_Usage","date":"2020-11-18T09:34:05.000Z","updated":"2020-11-18T09:34:05.000Z","comments":true,"path":"/2020/11/18/Git_Usage/","link":"","permalink":"https://ezrart.github.io/2020/11/18/Git_Usage/","excerpt":"","text":"GitGit是什么Git是一种源代码版本控制系统（VCS），什么叫版本控制系统呢？ 假设你写了一个Word文档，叫做《我的idea》.docx。 第一天，你blahblah写了不少点子，把它保存了下来； 第二天，你发现昨天的点子有一些纰漏，你将其更改了一些； 第三天，你发现第二天干坏事了，不小心删除了一个重要的点子，然而你已经想不起来那个点子了！ 这时就体现出版本控制系统的重要性了，版本控制系统可以记录你每一次的文件更改，如果你用了版本控制系统的话，你可以将你的文件还原到任意一次更改时的状况。 PS：git版本控制系统实际上不适合docx这类非纯文本文件，在此处只是举例，源代码（纯文本文件）才是git大放光彩的地方。 Git的用法详细用法不在此介绍我也不会 常见操作如下： 克隆服务器上的git项目 git clone xxxxx.git [可选：文件夹名] 其中“xxxxx.git”为你的项目地址。 执行完成后会看到当前目录下多出了一个文件夹，其名为[你克隆来的git项目名]&#x2F;[你指定的文件夹名]。 比如我克隆一个测试仓库，执行 git clone https://github.com/EzraRT/testgit.git 一番翻云覆雨后，就把代码仓库克隆下来了，得到一个如下的文件夹 进入该文件夹，里面存放了此代码仓库的最新代码，还有一个特殊的文件夹 这个.git文件夹，便是git仓库的数据文件，一般它是一个隐藏文件夹，需要手动开启“显示隐藏的项目”才能看到它。 对于其中的内容我们暂且不深入，只要知道它储存了一些git的数据即可。 这是我不久前创建的代码仓库，仅有一个说明文件（README.md）和一个.gitignore文件。 接下来我们要介绍如何参与到代码改动的工作中去，让我们仔细地观察这张图 服务器：Remote 本地仓库：Repository 工作区：workspace 目录：Index 其中，本地仓库、工作区，目录都位于你的电脑上，只有服务器位于服务器上废话，而你编辑代码时所做的更改都位于你的工作区，如何一步一步地提交代码改动并上传到服务器呢？ 提交更改 git add 文件名 [文件名1] [文件名2] [...] 这个指令是告诉git你更改的文件，git会将这几个文件于此时此刻保存起来（将某些信息保存在.git文件夹中），注意，之后你对该文件执行了更改，需要重新执行一遍add命令，不然git认为它还是上一次执行add时的模样。 git commit -m &quot;提交信息&quot; 这便提交了你的代码更改操作，你应在[提交信息]中简明扼要地说明你对代码进行了何种改动。 如果你进行了很多文件的更改，不想一个一个add它们，也可以执行： git commit -a -m &quot;提交信息&quot; 这个-a选项即是让git把所有未add、但发生了更改的文件记录下来准备提交。一般地，使用此种方法可以快速地提交你的代码更改。 获取服务器上的最新版本代码 在你克隆下来的git项目的目录下执行（先别执行！） git pull 但git常常用在团队合作中，如果有人在你之前更改了服务器上的代码，而你浑然不知，改了一些代码，准备提交到服务器上，傻傻地获取最新代码然后提交你的改动，这时会发生什么状况呢？ 情况1：你和他改动的代码并无冲突（你们更改的不是同一个文件或是同一个文件的不同部分） 情况2：你和他的改动有git难以处理的冲突，此时强行pull会造成很多的问题，比如你的改动被覆盖(白干半天）。 关于这几种情况处理起来比较复杂（虽然git是有处理方法的），我们介绍一种比较好的处理方式。 先执行 git fetch 获取服务器上的最新代码，但不合并到你本地的代码中。如何理解这句话？让我们回到这张图 你add&amp;commit操作都是在本地进行的操作，服务器浑然不知你的工作，而你不想白干活，因此要从服务器上fetch（拉取）服务器上的最新改动，并以此判断是否需要提交你的更改，同时也可以完成一些冲突的处理。但如果执行了pull操作，便会把代码改动直接应用到你的工作区，如果正好有人在你之前提交了某文件的更改，而你恰好也更改了它，这就是悲剧的开始。 因此，先fetch下代码改动并利用diff工具（代码比较工具）查看改动，确认没有冲突之后再pull并提交代码改动。 提交代码更改给服务器 终于到了这一激动人心的一刻，你的工作将被记录下来并保存到服务器上，执行 git push 便可以将你此前提交的代码更改（commit）告诉服务器了。如果执行push时git告诉你：“你的代码不是最新版本”，那想必是你又慢人一步了，请从第2点重新操作。 ​ 总结：参与到某git项目的代码维护工作中，你需要做的事有： ​ 首先，clone对应的项目； ​ 参与代码的改动工作，进行代码改动的基本流程如下： ​ fetch服务器的更改、仔细比较并确认、pull拉取最新的代码更改到你的工作区，commit提交你的代码改动、push上传你的代码改动到服务器。 日常使用的Git用法（利用软件集成的版本控制系统）生活在现代的我们，往往不用操作如此繁琐的命令，此处介绍VSCode的图形化git工具，它可以帮助我们完成大部分的工作。 有关VSCode安装的相关教程可以查看这个 首先用VSCode打开我们git项目的目录，进行一番改动后，界面如下 对于这几处，与你平常编写代码时不一样的显示，我们从左到右进行说明。 文件改动列表（版本控制栏） 最左边，标记了一个数字，这是VSCode集成的版本管理系统（git工具），其界面如下图 你对文件进行的更改都会罗列在此处，本例中，我们改动了test.cc文件、新建了main.cc文件、删除了README.md文件，在此处点击它，便可以在右侧看到它与上一次提交的变化 左侧为改动前的文件，右侧为改动后的文件，此处我们将一句感叹编写成了一个可以编译执行的感叹。 某文件改动情况 对于有所改动的文件，它会在文件名右方显示改动的类型 蓝色的M是modified的意思，译为已被更改，说明我们对此文件进行了更改操作； 绿色的U，untracked，说明你新建了该文件且没有提交； 红色的D（可以在1：文件改动列表中查看），deleted，说明你删除了该文件。 每一行的改动情况 对应颜色与上述文件改动类型对应 这时我们如何利用图形界面进行commit、pull、push操作呢？ 在版本控制栏中，点击文件名后面的小加号可以把它提交到舞台上（OnStage），接着在上方的Message栏输入你的提交说明，最后点击这个勾，便将你[提交到Stage]的改动commit完成了。 最后，将你的代码改动push到服务器上去 等等！pull、fetch操作呢？说好的代码安全呢？ 在VSCode的左下角，有一个循环模样的小按钮 其旁边的数字指示了你比服务器落后了多少个commit（下载箭头指示，可能是别人提交的）、你比服务器领先多少个commit（上传箭头指示，你想要提交的代码更改）。 点击它，便会执行pull&amp;push操作，且在与服务器有冲突时会询问你该怎么办。具体情况具体对待，此处不做延伸。 这便是我们日常使用中对git的使用，相比命令行，对文件的改动变得显而易见，你可以利用图形化的diff工具比较每一处改动、用版本控制工具查看文件历史（该文件的每次更改情况）等等。 附录：.gitignore文件是什么呢？ignore的意思是忽略，此文件是一个文本文件，里面罗列了git进行代码比较、提交更改时忽略的文件、文件类型、文件夹等等。","categories":[{"name":"软件教程","slug":"软件教程","permalink":"https://ezrart.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://ezrart.github.io/tags/Git/"},{"name":"教程","slug":"教程","permalink":"https://ezrart.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"Windows下使用VSCode和GCC的C++开发环境配置","slug":"VSCode-C-C-Config","date":"2020-11-16T14:22:11.000Z","updated":"2020-11-17T07:54:20.000Z","comments":true,"path":"/2020/11/16/VSCode-C-C-Config/","link":"","permalink":"https://ezrart.github.io/2020/11/16/VSCode-C-C-Config/","excerpt":"","text":"C++环境配置 下载软件 下载vscode安装程序与gcc的压缩包。 安装软件 安装vscode 选择安装目录：推荐安装在： D:\\Program Files\\Microsoft VS Code 一路next，记得勾选这两项（还有勾选创建桌面图标，方便寻找） 一路next，安装完成后进入下一步 安装GCC编译环境 解压7z后缀的压缩包，得到名叫mingw64的文件夹 创建GCC安装文件夹，推荐 D:\\Program Files\\GCC 将解压得到的文件夹中的所有东西复制到此GCC文件夹中，效果如下 GCC至此安装完成，进入下一步 环境变量设置 打开控制面板 依次进入 系统与安全——系统——高级系统设置（位于左侧） 在弹出的窗口中点击环境变量 在下方的小窗口中寻找变量Path，点击编辑 在新弹出的窗口中，点击新建，接着输入 你安装GCC的目录\\bin 如果你一路顺着我的教程安装完GCC，那么你应该输入的是 D:\\Program Files\\GCC\\bin 输入完成后依次点击所有窗口的OK（确定），来保存环境变量设置，若中途任意一个窗口点击了Cancel（取消），请从环境变量设置章节开始重新设置。 测试环境设置是否正确&#x2F;生效 按下键盘上的Windows键+R，弹出运行窗口 ​ 输入cmd，点击OK（确定） ​ 弹出一个黑窗口 ​ 输入 gcc -v ​ 敲击回车执行，将会看到以下输出 ​ 恭喜你，环境变量设置完成了，进入下一步 PS：若看到“gcc”不是一个blahblah，说明上述步骤设置错误，请重新设置环境变量 配置vscode环境 打开安装好的vscode 点击左侧Extension（插件）按钮 搜索以下插件并安装 C/C++Code Runner 如果你看不懂英文界面可以安装中文插件，大概是叫Chinese Simplified 上述插件安装完成后，关闭vscode，再打开，使插件生效 打开设置 PS：若打开设置显示的是一个文本文件，自请查阅“如何打开vscode设置UI“ 搜索并设置Default Intelli Sense Mode选项，将其设置为gcc-x64 搜索Code-runner:Run In Terminal选项，勾选它 搜索Code-runner: Save All Files Before Run选项，勾选它 PS：此选项是为了防止运行前忘记保存代码。 请从现在开始，养成随手按Ctrl+S保存文件的好习惯。 （同样适用于Office、Adobe全家桶等软件） 退出设置 编写代码来测试你的环境配置 点击左上角的文件——打开文件夹 选择你用来保存代码的目录 创建一个新的代码文件如main.c，输入你的测试代码 #include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; printf(&quot;Hello World!\\n&quot;); return 0;&#125; 点击右上角的三角形按钮 下方终端会显示一系列命令，左侧工作目录中增加了编译生成的exe可执行文件，最终在下方终端中自动运行你的程序。 你应该可以看到程序所输出的Hello World! 至此vscode+gcc的开发环境配置完毕，你还可以探索更多的vscode的用法","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://ezrart.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://ezrart.github.io/tags/C-C/"},{"name":"环境配置","slug":"环境配置","permalink":"https://ezrart.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]}],"categories":[{"name":"编译工具","slug":"编译工具","permalink":"https://ezrart.github.io/categories/%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/"},{"name":"软件教程","slug":"软件教程","permalink":"https://ezrart.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/"},{"name":"环境配置","slug":"环境配置","permalink":"https://ezrart.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://ezrart.github.io/tags/C-C/"},{"name":"编译","slug":"编译","permalink":"https://ezrart.github.io/tags/%E7%BC%96%E8%AF%91/"},{"name":"cmake","slug":"cmake","permalink":"https://ezrart.github.io/tags/cmake/"},{"name":"makefile","slug":"makefile","permalink":"https://ezrart.github.io/tags/makefile/"},{"name":"Git","slug":"Git","permalink":"https://ezrart.github.io/tags/Git/"},{"name":"教程","slug":"教程","permalink":"https://ezrart.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"环境配置","slug":"环境配置","permalink":"https://ezrart.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]}